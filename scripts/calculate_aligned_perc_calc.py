import glob, argparse, os

description = '''

Input:  reference fasta, directory with .coords files generated by MUMmer
Params:
    min_length    : minimum length of an alignment to be considered in calculating the overlap
    min_identity  : minimum perc. identity of an alignment to be considered in calculating the overlap

Output:
    list of contigs that considered 'core' accoriding to the abovementioned specifications, printed to stdout

'''


def init_args():
    parser = argparse.ArgumentParser(description=description)

    input_options = parser.add_argument_group('Input options')
    input_options.add_argument("-referenceName", dest='reference_name', type = str, help='Name of the reference genome.', required=True)
    input_options.add_argument("-inDir", dest='indir', type = str, help='Name of the folder that contains the .coords files generated by MUMmer.', required=True)
    input_options.add_argument("-deltaFile", dest='deltafile', type = str, help='delta file from nucmer', required=True)

    settings = parser.add_argument_group('Parameter settings')
    settings.add_argument("-minLength", dest='min_length', type=str, default = '1000', help = "Minimum length of alignment to be included")
    settings.add_argument("-minIdentity", dest='min_identity', type=str, default = '90.0', help = "Minimum percent identity of alignment to be included")
    output_options = parser.add_argument_group('Output settings')
    output_options.add_argument("-outDir", dest='outdir', type = str, help='Name of the output folder', required=True)
    output_options.add_argument("-outFile", dest='outfile', type = str, help='Name of the output file. If the file already exists then output will be appended to the file.', required=True)

    args = parser.parse_args()

    return args

args = init_args()
os.system('export LC_NUMERIC=C')
coords_files = glob.glob(args.indir+'/'+args.reference_name+'.coords')
coords_lists_per_query = []

for coords_fname in coords_files:
    #print(coords_fname)
    query_id = coords_fname.split('/')[-1].split('.vs.')[-1].split('.')[0]
    #print(query_id)
    # filter alignment and write to temporary bedfile
    coords2bed_cmnd = "awk -v OFS='\\t' '{if ($10 >= "+args.min_identity+" && $7 >= "+args.min_length+") print $12,$1,$2}' "+coords_fname+" > "+coords_fname.replace(".coords", ".tmp.bed")

    # merge overlapping and touching regions to avoid counting partial regions twice
    bedtools_merge_cmnd = 'bedtools merge -i '+coords_fname.replace(".coords", ".tmp.bed")+" > "+coords_fname.replace(".coords", ".tmp.nr.bed")

    # calculate aligned percentage
    matched_bases = "awk -v OFS='\\t' '{print $0, $3-$2}' "+coords_fname.replace(".coords", ".tmp.nr.bed")+" | awk -v OFS='\\t' '{sum+=$4;} END{print sum}' > "+coords_fname.replace(".coords", "aligned.num")
    total_bases = "awk 'FNR==3 {print $3}' "+args.deltafile+" > "+coords_fname.replace(".coords", "total.num")

    if os.system(coords2bed_cmnd) == 0:
        #print("coords2bed_cmnd works")
        if os.system(bedtools_merge_cmnd) == 0:
            #print("bedtools_merge_cmnd works")
            if os.system(matched_bases) == 0:
                #print("matched_bases works")
                if os.system(total_bases) == 0:
                    #print("total_bases works")
                    coords_lists_per_query.append(args.outdir+'/'+args.reference_name+'_contigs_in_'+query_id)

    with open(coords_fname.replace(".coords", "aligned.num")) as f:
        for line in f:
            for s in line.split(' '):
                aligned_num = int(s)
                #print(aligned_num)
        f.close()

    with open(coords_fname.replace(".coords", "total.num")) as f:
        for line in f:
            for s in line.split(' '):
                total_num = int(s)
                #print(total_num)
        f.close()

    myfile = args.outdir+"/"+args.outfile
    if os.path.isfile(myfile):
        #print("appending to file")
        # Append output to file
        with open(myfile, "a") as f:
            f.write(args.reference_name+"\t"+str(100*aligned_num/total_num)+"%\n")
            f.close()

    else:
        #print("creating file")
        # Create new output files
        with open(myfile, "w") as f:
            f.write(args.reference_name+"\t"+str(100*aligned_num/total_num)+"%\n")
            f.close()
    #print(aligned_num/total_num*100)
